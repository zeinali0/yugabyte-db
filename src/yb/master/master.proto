// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
//
// The following only applies to changes made to this file as part of YugaByte development.
//
// Portions Copyright (c) YugaByte, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.  You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software distributed under the License
// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
// or implied.  See the License for the specific language governing permissions and limitations
// under the License.
//
syntax = "proto2";

package yb.master;

option java_package = "org.yb.master";

import "yb/common/common.proto";
import "yb/common/wire_protocol.proto";
import "yb/consensus/metadata.proto";
import "yb/tablet/metadata.proto";
import "yb/util/encryption.proto";
import "yb/cdc/cdc_consumer.proto";

////////////////////////////////////////////////////////////
// Common data structures
////////////////////////////////////////////////////////////

// Master specific errors use this protobuf.
message MasterErrorPB {
  enum Code {
    // An error which has no more specific error code.
    // The code and message in 'status' may reveal more details.
    //
    // RPCs should avoid returning this, since callers will not be
    // able to easily parse the error.
    UNKNOWN_ERROR = 1;

    // The schema provided for a request was not well-formed.
    INVALID_SCHEMA = 2;

    // The requested table or index does not exist
    OBJECT_NOT_FOUND = 3;

    // The name requested for the table or index is already in use
    OBJECT_ALREADY_PRESENT = 4;

    // The number of tablets requested for a new table is over the per TS limit.
    TOO_MANY_TABLETS = 5;

    // Catalog manager is not yet initialized.
    CATALOG_MANAGER_NOT_INITIALIZED = 6;

    // The operation attempted can only be invoked against either the
    // leader or a single non-distributed master, which this node
    // isn't.
    NOT_THE_LEADER = 7;

    // The number of replicas requested is greater than the number of live servers
    // in the cluster.
    REPLICATION_FACTOR_TOO_HIGH = 8;

    // Change config should always be issued with the latest config version set.
    // If the client fails to do so, or there is a concurrent change, we will
    // set this error code.
    CONFIG_VERSION_MISMATCH = 9;

    // If there is an operation in progress causing the current rpc to be in an indeterminate state,
    // we return this error code. Client can retry on a case by case basis as needed.
    IN_TRANSITION_CAN_RETRY = 10;

    // Invalid namespace name or id for the namespace operation.
    NAMESPACE_NOT_FOUND = 11;
    NAMESPACE_ALREADY_PRESENT = 12;
    NO_NAMESPACE_USED = 13;
    NAMESPACE_IS_NOT_EMPTY = 14;

    // Client set some fields incorrectly in the cluster config proto.
    INVALID_CLUSTER_CONFIG = 15;

    // Indicator to client that the load balance operation can be retried.
    CAN_RETRY_LOAD_BALANCE_CHECK = 16;

    // Invalid (User-Defined) Type operation
    TYPE_NOT_FOUND = 17;
    INVALID_TYPE = 18;
    TYPE_ALREADY_PRESENT = 19;

    // Snapshot related errors.
    INVALID_TABLE_TYPE = 20;
    TABLE_CREATION_IS_IN_PROGRESS = 21;
    SNAPSHOT_NOT_FOUND = 22;
    SNAPSHOT_FAILED = 23;
    SNAPSHOT_CANCELLED = 24;
    PARALLEL_SNAPSHOT_OPERATION = 25;
    SNAPSHOT_IS_NOT_READY = 26;

    // Roles and permissions errors.
    ROLE_ALREADY_PRESENT = 27;
    ROLE_NOT_FOUND = 28;
    INVALID_REQUEST = 29;
    NOT_AUTHORIZED = 32;

    // Indicator to client that the are leaders on preferred only operation can be retried.
    CAN_RETRY_ARE_LEADERS_ON_PREFERRED_ONLY_CHECK = 30;

    REDIS_CONFIG_NOT_FOUND = 31;

    // Indicator to client that load balancer was recently active.
    LOAD_BALANCER_RECENTLY_ACTIVE = 33;

    INTERNAL_ERROR = 34;

    // Client set some fields in the table replication info incorrectly.
    INVALID_TABLE_REPLICATION_INFO = 35;

    REACHED_SPLIT_LIMIT = 36;
  }

  // The error code.
  required Code code = 1;

  // The Status object for the error. This will include a textual
  // message that may be more useful to present in log messages, etc,
  // though its error code is less specific.
  required AppStatusPB status = 2;
}

// Common information sent with every request from the tablet server
// to the master.
message TSToMasterCommonPB {
  // The instance of the tablet server sending the heartbeat.
  required NodeInstancePB ts_instance = 1;
}

message NamespaceIdentifierPB {
  // The namespace ID to fetch info.
  optional bytes id = 1;

  // The namespace name to fetch info.
  optional string name = 2;

  // Database type.
  optional YQLDatabase database_type = 3 [ default = YQL_DATABASE_CQL ];
}

message TableIdentifierPB {
  // The table ID to fetch info.
  optional bytes table_id = 1;

  // The table name to fetch info.
  optional string table_name = 2;

  // The table namespace (if empty - using default namespace).
  optional NamespaceIdentifierPB namespace = 3;
}

message TablegroupIdentifierPB {
  // The tablegroup ID to fetch info.
  optional bytes id = 1;

  // The tablegroup name to fetch info.
  optional string name = 2;

  // The namespace that the tablegroup is in
  optional bytes namespace_id = 3;
}

// This represents one instance of a placement constraint for a table. It is
// used to dictate what is the minimum number of expected replicas in a certain
// cloud/region/zone combo.
message PlacementBlockPB {
  // The cloud, region and zone information for this placement block.
  optional CloudInfoPB cloud_info = 1;

  // The minimum number of replicas that should always be up in this placement.
  optional int32 min_num_replicas = 2;
}

// This keeps track of the set of PlacementBlockPBs defining the placement
// requirements for a certain table. This is used both in the on-disk storage
// in SysCatalog, as well as in the actual table creation calls and in the
// schema returned to client queries.
//
// This is tightly coupled with the overall num_replicas for a certain table,
// as we want to both be able to specify requirements, per placement block, but
// also for the overall RF factor of the table.
message PlacementInfoPB {
  optional int32 num_replicas = 1;
  repeated PlacementBlockPB placement_blocks = 2;
  optional bytes placement_uuid = 3;
}

// Higher level structure to keep track of all types of replicas configured. This will have, at a
// minimum, the information about the replicas that are supposed to be active members of the raft
// configs, but can also include extra information, such as read only replicas.
message ReplicationInfoPB {
  optional PlacementInfoPB live_replicas = 1;
  repeated PlacementInfoPB read_replicas = 2;
  repeated CloudInfoPB affinitized_leaders = 3;
}

// This is used to mark servers in the load balancer that should be considered
// for immediate removal of load and also prevented from being assigned any
// new load.
message BlacklistPB {
  repeated HostPortPB hosts = 1;

  // Fields to track the number of replicas/leaders in current set of tablets which have a
  // blacklist server/leader. Client should not set this. Set by server side when persisting
  // the blacklist load.
  optional int32 initial_replica_load = 2;
  optional int32 initial_leader_load = 3;
}

////////////////////////////////////////////////////////////
// Sys Tables Metadata
////////////////////////////////////////////////////////////

// The actual on disk abstract representation of a row in the sys catalog.
// This has to respect the fixed schema of the catalog. In case of changes to
// the schema, this proto must reflect them.
message SysRowEntry {
  enum Type {
    UNKNOWN = 0;
    TABLE = 1;
    TABLET = 2;
    CLUSTER_CONFIG = 3;
    NAMESPACE = 4;
    UDTYPE = 5;
    ROLE = 6;
    SNAPSHOT = 7;
    REDIS_CONFIG = 8;
    SYS_CONFIG = 9;
    CDC_STREAM = 10;
    UNIVERSE_REPLICATION = 11;
  }

  // The type of entry we are storing. Since the data is serialized, we cannot
  // just store it with
  // the data, as we are not able to read into the appropriate type.
  optional Type type = 1;

  // The optional ID of the data that we are storing. This can be useful to only
  // read information
  // related to a single item, in the case of tables or tablets, for example.
  // This is optional.
  optional string id = 2;

  // This is the serialized format of the proto we store. This used to be of the "string" type, but
  // was giving warnings due to non-UTF8 data. This is safe, because "bytes" and "string" are
  // encoded the same way in Protobuf.
  // https://groups.google.com/forum/#!msg/protobuf/au6eQBkRT5s/Bhpctql7Q5sJ
  optional bytes data = 3;
}

message SysRowEntries {
  repeated SysRowEntry entries = 1;
}

// The on-disk entry in the sys.catalog table ("metadata" column) for
// tablets entries.
message SysTabletsEntryPB {
  enum State {
    UNKNOWN = 999;
    PREPARING = 0;
    CREATING = 1;
    RUNNING = 2;
    REPLACED = 3;
    DELETED = 4;
  }

  // DEPRECATED. Replaced by 'partition'.
  optional bytes OBSOLETE_start_key = 1;
  optional bytes OBSOLETE_end_key = 2;

  // Tablet partition.
  optional PartitionPB partition = 7;

  // The latest committed consensus configuration reported to the Master.
  optional consensus.ConsensusStatePB committed_consensus_state = 3;

  // Debug state for the tablet.
  optional State state = 4 [ default = UNKNOWN ];
  optional bytes state_msg = 5;

  // The table id for the tablet.
  required bytes table_id = 6;
  // Table ids for all the tables on this tablet.
  repeated bytes table_ids = 8;

  // True if the tablet is colocated.
  optional bool colocated = 9 [ default = false ];

  // Replaced by the map below.
  optional bytes DEPRECATED_backfilled_until = 10;

  // For tablets that are results of splitting we set this to split parent split_depth + 1.
  optional uint64 split_depth = 11;

  optional bytes split_parent_tablet_id = 13;

  // If the tablet is in the backfilling state, this is used to keep track
  // of how far along backfill has completed.
  // Key corresponds to the table_id for the index table. Value is encoded as
  // the DocKey for the next row to be backfilled.
  map<string, bytes> backfilled_until = 12;
}

// The on-disk entry in the sys.catalog table ("metadata" column) for
// tables entries.
message SysTablesEntryPB {
  enum State {
    UNKNOWN = 0;
    PREPARING = 1;
    RUNNING = 2;
    ALTERING = 3;
    DELETING = 4;
    DELETED = 5;
  }

  // Table name
  required bytes name = 1;

  // Table type
  optional TableType table_type = 10 [ default = DEFAULT_TABLE_TYPE ];

  // The table namespace ID.
  optional bytes namespace_id = 11;
  // The table namespace name.
  optional bytes namespace_name = 30;

  // sequence-id for the table metadata.
  // Used on tablet-report to avoid sending "alter-table" notifications.
  required uint32 version = 2;

  // Newest table schema (every TS will eventually have it).
  required SchemaPB schema = 3;

  // Last table schema that is guaranteed to have reached every TS, though
  // not necessarily the newest schema.
  //
  // This is the schema provided to the user on client->GetSchema(tableName).
  optional SchemaPB fully_applied_schema = 4;

  // The table's partitioning schema.
  optional PartitionSchemaPB partition_schema = 9;

  // The table's partitions version. Incremented each time partitions change.
  optional uint32 partitions_version = 28;

  // The next column ID to assign to newly added columns in this table.
  // This prevents column ID reuse.
  optional int32 next_column_id = 8;

  // Replication information for this tablet.
  optional ReplicationInfoPB replication_info = 5;

  // Debug state for the table.
  optional State state = 6 [ default = UNKNOWN ];
  optional bytes state_msg = 7;

  // TODO(neil) OLDER INDEXes will always have the deprecated fields. To remove the old format, we
  // first need to come up with a way to convert existing catalog content to new format.
  // Secondary indexes of the table.
  repeated IndexInfoPB indexes = 12;

  // For index table: [to be deprecated and replaced by "index_info"]
  optional bytes indexed_table_id = 13; // Indexed table id of this index.
  optional bool is_local_index = 14 [ default = false ];  // Whether this is a local index.
  optional bool is_unique_index = 15 [ default = false ]; // Whether this is a unique index.

  // For index table: information about this index.
  optional IndexInfoPB index_info = 22;

  // For Postgres:
  optional bool is_pg_shared_table = 16 [ default = false ]; // Is this a shared table?

  optional uint32 wal_retention_secs = 24;

  optional bool colocated = 25 [ default = false ]; // Is this a colocated table?

  // Denotes the tablespace to which this table belongs.
  optional bytes tablespace_id = 31;

  // For index backfill/schema related changes.
  // When a schema change is going on, we want to make sure that the master returns the "older"
  // fully applied version until all the tablets have moved on to the newer version.
  optional uint32 fully_applied_schema_version = 23;
  repeated IndexInfoPB fully_applied_indexes = 26;
  optional IndexInfoPB fully_applied_index_info = 27;

  // Optional: Table dependent upon transaction success (abort removes table). Used by YSQL.
  optional TransactionMetadataPB transaction = 29;
}

// The data part of a SysRowEntry in the sys.catalog table for a namespace.
message SysNamespaceEntryPB {
  enum State {
    UNKNOWN = 0;    // Unset or bad data. Unexpected state.
    PREPARING = 1;  // Creating. Transitive State. Possible Next States: [RUNNING, FAILED].
    FAILED = 2;     // Creation Failed. Permanent State.
    RUNNING = 3;    // Live. Permanent State. Possible Next States: [FAILED, DELETING].
    DELETING = 4;   // Delete Requested. Transitive State. Possible Next States: [DELETED].
    DELETED = 5;    // Delete Finished on TServers or Tombstone. Final State before erasure.
  }
  // Note: The id of the namespace is not stored here as it is already part of
  // SysRowEntry's id component.

  // Namespace name.
  optional bytes name = 1;

  // Namespace/Database type.
  optional YQLDatabase database_type = 2 [ default = YQL_DATABASE_CQL ];

  // For Postgres:
  optional uint32 next_pg_oid = 3; // Next oid to assign.

  // True if the namespace is colocated.
  optional bool colocated = 4 [ default = false ];

  // Optional: Namespace dependent upon transaction success (abort removes NS). Used by YSQL.
  optional TransactionMetadataPB transaction = 6;

  optional State state = 5 [ default = UNKNOWN ];
}

// The data part of a SysRowEntry in the sys.catalog table for a User Defined Type.
message SysUDTypeEntryPB {
  optional string namespace_id = 1;
  optional string name = 2;
  repeated string field_names = 3;
  repeated QLTypePB field_types = 4;
}

// The data part of a SysRowEntry in the sys.catalog table for Redis Config.
message SysRedisConfigEntryPB {
  optional string key = 1;
  repeated bytes args = 2;
}

// The data part of a SysRowEntry in the sys.catalog table for a CDC stream.
message SysCDCStreamEntryPB {
  enum State {
    ACTIVE = 0;
    DELETING = 1;
    // Currently DELETED is not being used because we delete streams entries from sys catalog.
    DELETED = 2;
  }
  optional string table_id = 1;
  repeated CDCStreamOptionsPB options = 2;
  optional State state = 3 [default = ACTIVE];
}

// The data part of a SysRowEntry in the sys.catalog table for a universe replication record.
message SysUniverseReplicationEntryPB {
  enum State {
    // Setting up replication.
    INITIALIZING = 0;
    // Validated table schemas.
    VALIDATED = 1;
    // Active.
    ACTIVE = 2;
    // Failed.
    // Setting up universe replication consists of a sequence of steps like validating schemas,
    // creating CDC streams, starting subscribers. If any of these fail, we set the universe
    // replication state to FAILED.
    FAILED = 3;
    // Disabled.
    DISABLED = 6;
    // Deleted.
    DELETED = 4;
    // Error while cleaning up state of deleted entry. This indicates that universe replication has
    // been deleted but there is still some uncleaned up state - for example, there may be left over
    // CDC streams.
    DELETED_ERROR = 5;
  }

  optional string producer_id = 1;
  repeated HostPortPB producer_master_addresses = 2;

  // producer table IDs.
  repeated string tables = 3;

  optional State state = 4 [default = INITIALIZING];

  // producer table ID -> consumer table ID map.
  map<string, string> validated_tables = 5;

  // producer table ID -> producer CDC stream map.
  map<string, string> table_streams = 6;
}

message ChangeEncryptionInfoRequestPB {
  optional bool encryption_enabled = 1;
  optional string key_path = 2;
  optional string version_id = 3;
  optional bool in_memory = 4;
}

message ChangeEncryptionInfoResponsePB {
  optional MasterErrorPB error = 1;
}

message IsEncryptionEnabledRequestPB {
}

message IsEncryptionEnabledResponsePB {
  optional bool encryption_enabled = 1;
  optional string key_id = 2;
  optional MasterErrorPB error = 3;
}

message EncryptionInfoPB {
  optional bool encryption_enabled = 1;
  optional bytes universe_key_registry_encoded = 2;
  optional string key_path = 3;
  optional string latest_version_id = 4;
  optional bool key_in_memory = 5;
}

message AddUniverseKeysRequestPB {
  optional UniverseKeysPB universe_keys = 1;
}

message AddUniverseKeysResponsePB {
  optional MasterErrorPB error = 1;
}

message GetUniverseKeyRegistryRequestPB {
}

message GetUniverseKeyRegistryResponsePB {
  optional MasterErrorPB error = 1;
  optional UniverseKeysPB universe_keys = 2;
}

message HasUniverseKeyInMemoryRequestPB {
  optional string version_id = 1;
}

message HasUniverseKeyInMemoryResponsePB {
  optional bool has_key = 1;
  optional MasterErrorPB error = 2;
}


// The on-disk entry in the sys.catalog table for configuration vinformation
// that are relevant to the entire cluster. This has a version entry that is
// used for ensuring that client read-modify-writes are valid.
message SysClusterConfigEntryPB {
  optional int32 version = 1;
  optional string cluster_uuid = 4;
  optional ReplicationInfoPB replication_info = 2;
  optional BlacklistPB server_blacklist = 3;
  optional BlacklistPB leader_blacklist = 7;
  optional EncryptionInfoPB encryption_info = 5;
  optional cdc.ConsumerRegistryPB consumer_registry = 6;
}

message SysRoleEntryPB {
  optional bytes role = 1;
  optional bool can_login = 2;
  optional bool is_superuser = 3;
  repeated bytes member_of = 4;
  optional bytes salted_hash = 5;
  repeated ResourcePermissionsPB resources = 7;
}

// Cluster security configuration.
message SysSecurityConfigEntryPB {
  // Roles configuration version. Every time a role gets created/deleted, or a permission gets
  // added/removed, we increase the version.
  optional uint64 roles_version = 1;
}

// Metadata about the YSQL catalog (current only version).
message SysYSQLCatalogConfigEntryPB {
  // YSQL catalog version. Every time the catalog tables are changed (i.e. by DDL statements)
  // this version gets incremented.
  optional uint64 version = 1;

  // This is true if the master ran initdb and it finished, succesfully or not.
  optional bool initdb_done = 2;

  // If this is set, initdb has failed.
  optional string initdb_error = 5;

  // true if transactional system catalogs have been enabled on this cluster. This means all
  // YSQL system catalog tables have been made transactional, both in their schema and in the tablet
  // metadata.
  optional bool transactional_sys_catalog_enabled = 6;
}

// Various cluster configuration.
message SysConfigEntryPB {
  oneof config {
    SysSecurityConfigEntryPB security_config = 1;
    SysYSQLCatalogConfigEntryPB ysql_catalog_config = 2;
  }
}

message ResourcePermissionsPB {
  optional string resource_name = 1;
  optional string canonical_resource = 11;
  optional string namespace_name = 12;
  optional ResourceType resource_type = 2;
  repeated PermissionType permissions = 13;
}

////////////////////////////////////////////////////////////
// RPCs
////////////////////////////////////////////////////////////

// Sent by the TS when it first heartbeats with a master. This sends the
// master all of the necessary information about the current instance
// of the TS.
message TSRegistrationPB {
  optional ServerRegistrationPB common = 1;

  // Capabilities supported byt this TS.
  repeated fixed32 capabilities = 2;
}

message ReportedTabletPB {
  required bytes tablet_id = 1;
  optional tablet.RaftGroupStatePB state = 2 [ default = UNKNOWN ];
  optional tablet.TabletDataState tablet_data_state = 6 [ default = TABLET_DATA_UNKNOWN ];

  // The latest _committed_ consensus state.
  // This will be missing if the tablet is not in a RUNNING state
  // (i.e. if it is BOOTSTRAPPING).
  optional consensus.ConsensusStatePB committed_consensus_state = 3;

  optional AppStatusPB error = 4;
  optional uint32 schema_version = 5;
}

// Sent by the tablet server to report the set of tablets hosted by that TS.
message TabletReportPB {
  // If false, then this is a full report, and any prior information about
  // tablets hosted by this server should be dropped.
  required bool is_incremental = 1;

  // Tablets for which to update information. If 'is_incremental' is false,
  // then this is the full set of tablets on the server, and any tablets
  // which the master is aware of but not listed in this protobuf should
  // be assumed to have been removed from this server.
  repeated ReportedTabletPB updated_tablets = 2;

  // Tablet IDs which the tablet server has removed and should no longer be
  // considered hosted here. This will always be empty in a non-incremental
  // report.
  repeated bytes removed_tablet_ids = 3;

  // Every time the TS generates a tablet report, it creates a sequence
  // number. This can be useful in debugging, and also determining which
  // changes have not yet been reported to the master.
  // The first tablet report (non-incremental) is sequence number 0.
  required int32 sequence_number = 4;
}

message ReportedTabletUpdatesPB {
  required bytes tablet_id = 1;
  optional string state_msg = 2;
}

// Sent by the Master in response to the TS tablet report (part of the heartbeats)
message TabletReportUpdatesPB {
  repeated ReportedTabletUpdatesPB tablets = 1;
}

message TServerMetricsPB {
  optional int64 total_sst_file_size = 1;
  optional int64 total_ram_usage = 2;
  optional double read_ops_per_sec = 3;
  optional double write_ops_per_sec = 4;
  optional int64 uncompressed_sst_file_size = 5;
  optional uint64 uptime_seconds = 6;
  optional uint64 num_sst_files = 7;
}

message TabletForSplitPB {
  required bytes tablet_id = 1;
  required bytes split_partition_key = 2;
  required bytes split_encoded_key = 3;
}

// Heartbeat sent from the tablet-server to the master
// to establish liveness and report back any status changes.
message TSHeartbeatRequestPB {
  required TSToMasterCommonPB common = 1;

  // Sent upon start-up of the TS, or in response to 'needs_reregister' on a heartbeat
  // response.
  optional TSRegistrationPB registration = 2;

  // Sent when the tablet information has changed, or in response to
  // 'needs_full_tablet_report'.
  optional TabletReportPB tablet_report = 3;

  // TODO; add a heartbeat sequence number?

  // TODO: perhaps add some very basic metrics reporting here, like
  // free space, reqs/sec, etc?

  // The number of tablets that are BOOTSTRAPPING or RUNNING.
  // Used by the master to determine load when creating new tablet replicas.
  optional int32 num_live_tablets = 4;

  optional int32 config_index = 5;

  optional TServerMetricsPB metrics = 6;

  // Number of tablets for which this ts is a leader.
  optional int32 leader_count = 7;

  optional int32 cluster_config_version = 8;

  // List of candidate tablets for split based on tablet splitting strategy and settings.
  repeated TabletForSplitPB tablets_for_split = 9;
}

message TSHeartbeatResponsePB {
  optional MasterErrorPB error = 1;

  // As with most other master RPC responses (e.g.,
  // ListTablesResponsePB), all fields below are optional as they may
  // not be set if there is an error.

  optional NodeInstancePB master_instance = 2;

  // Indicates that the server which heartbeated needs to re-register
  // with the master -- i.e send a heartbeat with the 'registration'
  // filled in.
  optional bool needs_reregister = 3 [ default = false ];

  optional bool needs_full_tablet_report = 4 [ default = false ];

  // Sent when the master receives a TabletReport
  optional TabletReportUpdatesPB tablet_report = 5;

  // Specify whether or not the node is the leader master.
  optional bool leader_master = 6;

  // Piggyback the current config as known to the master leader.
  optional consensus.RaftConfigPB master_config = 7;

  // List of all live nodes that the master knows about.
  repeated TSInformationPB tservers = 8;

  // Cluster UUID. Sent by the master only after registration.
  optional string cluster_uuid = 9;

  // Current YSQL catalog schema version.
  // Used by tservers and postgres backends to decide if a cache refresh is needed.
  optional uint64 ysql_catalog_version = 10;

  optional uint64 ysql_last_breaking_catalog_version = 15;

  optional UniverseKeyRegistryPB universe_key_registry = 11;

  optional cdc.ConsumerRegistryPB consumer_registry = 12;

  optional int32 cluster_config_version = 13;

  optional int64 tablet_split_size_threshold_bytes = 14;
}

message TSInformationPB {
  required TSRegistrationPB registration = 1;
  required NodeInstancePB tserver_instance = 2;
}

//////////////////////////////
// GetTabletLocations
//////////////////////////////

message TabletLocationsPB {
  message ReplicaPB {
    required TSInfoPB ts_info = 1;
    required consensus.RaftPeerPB.Role role = 2;
    optional consensus.RaftPeerPB.MemberType member_type = 3;
  }

  required bytes tablet_id = 1;

  // DEPRECATED.
  optional bytes start_key = 2;
  optional bytes end_key = 3;

  optional PartitionPB partition = 6;

  repeated ReplicaPB replicas = 4;

  // true if the tablet was running but no tablet server has reported it yet.
  // The set of replicas will be the last one that was hosting the tablet.
  // This should happen on Master restart when the request is issued before
  // the TS has the time to notify the Master about the tablets that is hosting.
  required bool stale = 5;

  optional bytes table_id = 7;
  // Table ids for all the tables on this tablet.
  repeated bytes table_ids = 8;

  // See SysTabletsEntryPB for fields with the same name.
  optional uint64 split_depth = 9;
  optional bytes split_parent_tablet_id = 12;

  // Number of expected live replicas.
  optional int32 expected_live_replicas = 10;

  // Number of expected read replicas.
  optional int32 expected_read_replicas = 11;
}

// Info about a single tablet server, returned to the client as part
// of the GetTabletLocations response. This can be used on the client
// to update the local cache of where each TS UUID is located. In
// the future we may also want to transmit software version info,
// load info, topology, etc.
message TSInfoPB {
  required bytes permanent_uuid = 1;

  repeated HostPortPB private_rpc_addresses = 2;

  repeated HostPortPB broadcast_addresses = 5;

  optional CloudInfoPB cloud_info = 3;

  optional bytes placement_uuid = 4;

  // Capabilities of tablet server.
  repeated fixed32 capabilities = 6;
}

message GetTabletLocationsRequestPB {
  // The tablet IDs about which to fetch info.
  repeated bytes tablet_ids = 1;

  // If table ID is specified, table's partitions_version will be included into response.
  optional bytes table_id = 2;
}

message GetTabletLocationsResponsePB {
  optional MasterErrorPB error = 1;

  repeated TabletLocationsPB tablet_locations = 2;

  // If GetTabletLocationsRequestPB::table_id is set we return table's partitions_version for this
  // table (see SysTablesEntryPB::partitions_version).
  optional uint32 partitions_version = 4;

  message Error {
    required bytes tablet_id = 1;
    required AppStatusPB status = 2;
  }
  repeated Error errors = 3;
}

// ============================================================================
//  Catalog
// ============================================================================

// Create table request (including index table)
message CreateTableRequestPB {
  // TODO(proto3) reserved 4;

  required string name = 1;
  optional SchemaPB schema = 2;
  optional int32 num_tablets = 3;  // deprecated
  optional PartitionSchemaPB partition_schema = 5;
  optional ReplicationInfoPB replication_info = 6;
  optional TableType table_type = 7 [ default = DEFAULT_TABLE_TYPE ];
  optional NamespaceIdentifierPB namespace = 8;

  // For index table.
  optional IndexInfoPB index_info = 16;
  optional bytes indexed_table_id = 9; // Indexed table id of this index.
  optional bool is_local_index = 10 [ default = false ];  // Is a local index?
  optional bool is_unique_index = 11 [ default = false ]; // Is a unique index?
  optional bool skip_index_backfill = 18 [ default = false ]; // Skip online schema migration for
                                                              // index?

  // For RBAC.
  optional string creator_role_name = 12;

  // For Postgres:
  optional bytes table_id = 13; // id to assign to this table.
  optional bool is_pg_catalog_table = 14 [ default = false ]; // Is this a sys catalog table?
  optional bool is_pg_shared_table = 15 [ default = false ];  // Is this a shared table?

  // Is this a colocated table? This field is only applicable for a colocated database.
  optional bool colocated = 17 [ default = true ];

  // This is only applicable for tablegroups. Eventually colocated will be deprecated.
  optional bytes tablegroup_id = 19;

 // DDL Dependent upon Transaction success (abort removes). Used by YSQL.
  optional TransactionMetadataPB transaction = 20;

// For YSQL tables, this denotes the tablespace that this table is associated with.
  optional bytes tablespace_id = 21;
}

message CreateTableResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;

  optional bytes table_id = 2;
}

message IsCreateTableDoneRequestPB {
  required TableIdentifierPB table = 1;
}

message IsCreateTableDoneResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;

  // true if the create operation is completed, false otherwise
  optional bool done = 3;
}

message TruncateTableRequestPB {
  repeated bytes table_ids = 1;
}

message TruncateTableResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;
}

message IsTruncateTableDoneRequestPB {
  optional bytes table_id = 1;
}

message IsTruncateTableDoneResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;

  // true if the truncate operation is completed, false otherwise
  optional bool done = 2;
}

message BackfillIndexRequestPB {
  // The index to backfill.
  optional TableIdentifierPB index_identifier = 1;
}

message BackfillIndexResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;

  // The indexed table to backfill.
  optional TableIdentifierPB table_identifier = 2;
}

// Delete table request (including index table).
message DeleteTableRequestPB {
  required TableIdentifierPB table = 1;
  optional bool is_index_table = 2 [ default = false ];
}

message DeleteTableResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;

  optional bytes table_id = 2;
  // For index table, the indexed table of this index.
  optional TableIdentifierPB indexed_table = 3;
}

message IsDeleteTableDoneRequestPB {
  required bytes table_id = 1;
}

message IsDeleteTableDoneResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;

  // true if the delete operation is completed, false otherwise
  optional bool done = 2;
}

enum RelationType {
  SYSTEM_TABLE_RELATION = 1;
  USER_TABLE_RELATION = 2;
  INDEX_TABLE_RELATION = 3;
}

message ListTablesRequestPB {
  // When used, only returns tables that satisfy a substring match on name_filter.
  optional string name_filter = 1;

  // Can be used to list tables for this one particular namespace.
  optional NamespaceIdentifierPB namespace = 2;

  // Exclude system tables.
  optional bool exclude_system_tables = 3 [default = false];

  // Can be used to filter tables based on RelationType
  repeated RelationType relation_type_filter = 4;
}

message ListTablesResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;

  message TableInfo {
    required bytes id = 1;
    required string name = 2;
    optional TableType table_type = 3;
    optional NamespaceIdentifierPB namespace = 4;
    optional RelationType relation_type = 5 [default = USER_TABLE_RELATION];
  }

  repeated TableInfo tables = 2;
}

message GetTableLocationsRequestPB {
  required TableIdentifierPB table = 1;

  // Partition-key range.
  optional bytes partition_key_start = 3;
  optional bytes partition_key_end = 4;

  optional uint32 max_returned_locations = 5 [ default = 10 ];

  optional bool require_tablets_running = 6;
}

message GetTableLocationsResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;

  repeated TabletLocationsPB tablet_locations = 2;
  optional TableType table_type = 3;

  // See SysTablesEntryPB for field with the same name.
  optional uint32 partitions_version = 4;

  optional bool creating = 5;
}

message AlterTableRequestPB {
  enum StepType {
    UNKNOWN = 0;
    ADD_COLUMN = 1;
    DROP_COLUMN = 2;
    RENAME_COLUMN = 3;

    // TODO(KUDU-861): this will subsume RENAME_COLUMN, but not yet implemented
    // on the master side.
    ALTER_COLUMN = 4;
  }
  message AddColumn {
    // The schema to add.
    // NOTE: the 'id' field of the schema should not be provided here --
    // the server will assign an ID.
    required ColumnSchemaPB schema = 1;
  }
  message DropColumn {
    // Name of the column to drop.
    required string name = 1;
  }
  message RenameColumn {
    // Name of the column to rename;
    required string old_name = 1;
    required string new_name = 2;
  }

  message Step {
    optional StepType type = 1 [ default = UNKNOWN ];

    // Exactly one of the following must be set, based on 'type'
    optional AddColumn add_column = 2;
    optional DropColumn drop_column = 3;
    optional RenameColumn rename_column = 4;
  }

  required TableIdentifierPB table = 1;
  repeated Step alter_schema_steps = 2;
  optional string new_table_name = 3;
  optional NamespaceIdentifierPB new_namespace = 4;
  optional TablePropertiesPB alter_properties = 5;
  optional uint32 wal_retention_secs = 6;

  // If set to true, SendAlterTableRequest will be sent even if no changes are specified in this
  // request.
  // This is useful to trigger index permissions update.
  optional bool force_send_alter_request = 7 [default = false];

  // Replication information for this table.
  optional ReplicationInfoPB replication_info = 8;
}

message AlterTableResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;

  optional uint32 schema_version = 2;
}

message IsAlterTableDoneRequestPB {
  required TableIdentifierPB table = 1;
}

message IsAlterTableDoneResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;

  // this is the current schema, or the 'new' schema version if an alter is in progress
  optional uint32 schema_version = 2;

  // true if the alter operation is completed, false otherwise
  optional bool done = 3;
}

message GetTableSchemaRequestPB {
  required TableIdentifierPB table = 1;
}

message GetTableSchemaResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;

  // This is the schema that every TS should be able to understand
  // if your alter is keeping the schema compatible.
  // In case of an alter table in progress, this is the previous schema;
  // otherwise it is the latest schema.
  optional SchemaPB schema = 2;

  // Table schema version
  optional uint32 version = 9;

  // The table's partition schema.
  optional PartitionSchemaPB partition_schema = 5;

  optional ReplicationInfoPB replication_info = 3;

  // True if the create operation is completed, false otherwise.
  optional bool create_table_done = 6;

  // The table type.
  optional TableType table_type = 7;

  // Table identifier
  optional TableIdentifierPB identifier = 8;

  // Secondary indexes of the table.
  repeated IndexInfoPB indexes = 10;

  // For index table: [to be deprecated and replaced by "index_info"]
  optional bytes OBSOLETE_indexed_table_id = 11; // Indexed table id of this index.

  // For index table: information about this index.
  optional IndexInfoPB index_info = 12;

  // True if table is colocated.
  optional bool colocated = 13;
}

// ============================================================================
//  Administration/monitoring
// ============================================================================

message ListTabletServersRequestPB {
  // If set to true, return only the tservers which are in the primary/sync cluster.
  optional bool primary_only = 1 [default = false];
}

message ListTabletServersResponsePB {
  optional MasterErrorPB error = 1;

  message Entry {
    required NodeInstancePB instance_id = 1;
    optional TSRegistrationPB registration = 2;
    optional int32 millis_since_heartbeat = 3;
    optional bool alive = 4;
    optional TServerMetricsPB metrics = 5;
  }
  repeated Entry servers = 2;
}

// GetMasterRegistrationRequest/Response: get the instance id and
// HTTP/RPC addresses for this Master server.
message GetMasterRegistrationRequestPB {
}

// TODO: Just use ServerRegistration here.
message GetMasterRegistrationResponsePB {
  // Node instance information is always set.
  required NodeInstancePB instance_id = 1;

  // These fields are optional, as they won't be set if there's an
  // error retrieving the host/port information.
  optional ServerRegistrationPB registration = 2;

  // This server's role in the consensus configuration.
  optional consensus.RaftPeerPB.Role role = 3;

  // Set if there an error retrieving the registration information.
  optional MasterErrorPB error = 4;
}

// ListMastersRequest/Response: get information about all of the known
// master servers, including this node from the in-memory options.
message ListMastersRequestPB {
}

message ListMastersResponsePB {
  // An entry for each individual master server.
  repeated ServerEntryPB masters = 1;

  // Set only if there's an error in retrieving the list of servers or
  // in getting this server's own local registration information.
  optional MasterErrorPB error = 2;
}

// ListMasterRaftPeersRequest/Response: get information about all of the known servers
// which are part of this master's version of the currently active Raft quorum. This also
// captures any inflight change config operations which are not yet tracked by in-memory options
// and hence can give a more current picture of peers compared with ListMastersResponse.
message ListMasterRaftPeersRequestPB {
}

message ListMasterRaftPeersResponsePB {
  // An entry for each individual master server.
  repeated consensus.RaftPeerPB masters = 1;

  // Set only if there's an error in retrieving the list of servers or
  // in getting this server's own local registration information.
  optional MasterErrorPB error = 2;
}

// Make the masters dump all their in-memory and on-disk state to their respective log files.
// Sent to the master leader first, and then propogated to its peers if peers_also is set to true.
message DumpMasterStateRequestPB {
  // Dump on-disk state known to this master - including sys.catalog and raft config related info
  optional bool on_disk = 1 [default = true];

  // If set to true, the leader sends request to all current peers to dump their state too.
  // The on_disk is sent along to peers too.
  optional bool peers_also = 2 [default = false];

  // If set to true, the dump will be returned back as a string in the response.
  // Else the dump will be saved into the master respective log files.
  optional bool return_dump_as_string = 3 [default = false];
}

message DumpMasterStateResponsePB {
  optional MasterErrorPB error = 1;
  optional string dump = 2;
}

message ChangeLoadBalancerStateRequestPB {
  optional bool is_enabled = 1;
}

message ChangeLoadBalancerStateResponsePB {
  optional MasterErrorPB error = 1;
}

message GetLoadBalancerStateRequestPB {
}

message GetLoadBalancerStateResponsePB {
  optional MasterErrorPB error = 1;
  optional bool is_enabled = 2;
}

// Update an ex-peer about its removal from the cluster.
message RemovedMasterUpdateRequestPB {
}

message RemovedMasterUpdateResponsePB {
  optional MasterErrorPB error = 1;
}

message GetMasterClusterConfigRequestPB {
}

message GetMasterClusterConfigResponsePB {
  optional MasterErrorPB error = 1;
  optional SysClusterConfigEntryPB cluster_config = 2;
}

message ChangeMasterClusterConfigRequestPB {
  optional SysClusterConfigEntryPB cluster_config = 1;
}

message ChangeMasterClusterConfigResponsePB {
  optional MasterErrorPB error = 1;
}

message SetPreferredZonesRequestPB {
  repeated CloudInfoPB preferred_zones = 1;
}

message SetPreferredZonesResponsePB {
  optional MasterErrorPB error = 1;
}

// Get the percentage of tablet data that got moved as part of a blacklist config change.
// Handled by the master leader and picked up by new leader on failover.
message GetLoadMovePercentRequestPB {
}

// Get the percentage of tablet leadership that got moved as part of a leader blacklist config
// change. Handled by the master leader and picked up by new leader on failover.
message GetLeaderBlacklistPercentRequestPB {
}

// When no errors, the percent reflects the progress of load removal from the blacklisted tservers.
message GetLoadMovePercentResponsePB {
  optional MasterErrorPB error = 1;

  // To be deprecated. Replaced by "100 * (total - remaining) / total".
  optional double percent = 2;

  optional uint64 remaining = 3;
  optional uint64 total = 4;
}

// Is load balancer idle.
message IsLoadBalancerIdleRequestPB {
}

// When no errors, load balancer is idle.
message IsLoadBalancerIdleResponsePB {
  optional MasterErrorPB error = 1;
}

// Get a master's notion being ready as the leader.
// NOTE: Should be used only for unit testing purposes.
message IsMasterLeaderReadyRequestPB {
}

// When no errors, the master will be deemed ready as per its catalog manager layer.
message IsMasterLeaderReadyResponsePB {
  optional MasterErrorPB error = 1;
}

// When no errors, the master leader will have balanced all the load across the live tservers.
// The client can send in an optional value for the expected number of servers. If the master
// finds fewer alive in its snapshot than these, it will consider the load imbalanced.
message IsLoadBalancedRequestPB {
  optional int32 expected_num_servers = 1;
}

message IsLoadBalancedResponsePB {
  // Any error being set implies that the load is not balanced across the servers.
  optional MasterErrorPB error = 1;
}

message AreLeadersOnPreferredOnlyRequestPB {
}

message AreLeadersOnPreferredOnlyResponsePB {
  // Any error being set implies that the leader load is not balanced across the servers.
  optional MasterErrorPB error = 1;
}

message AreTransactionLeadersSpreadRequestPB {
}

message AreTransactionLeadersSpreadResponsePB {
  // Any error being set implies transaction leaders are incorrectly respecting preferred zones.
  optional MasterErrorPB error = 1;
}

// ============================================================================
//  Namespace  (default namespace = ANY placement)
// ============================================================================
// Database type is added to metadata entries such that PGSQL clients cannot delete or connect to
// CQL database_type and vice versa.
message CreateNamespaceRequestPB {
  // Namespace name.
  optional string name = 1;

  // Database type.
  optional YQLDatabase database_type = 2 [ default = YQL_DATABASE_CQL ];

  // For RBAC.
  optional string creator_role_name = 3;

  // For Postgres:
  optional bytes namespace_id = 4; // id to assign to this namespace.
  optional bytes source_namespace_id = 5; // namespace id of the source database to copy from.
  optional uint32 next_pg_oid = 6; // Next oid to assign. Ignored when source_namespace_id is given
                                   // and the next_pg_oid from source namespace will be used.
 // DDL Dependent upon Transaction success (abort removes). Used by YSQL.
  optional TransactionMetadataPB transaction = 8;

  // True if the namespace is colocated.
  optional bool colocated = 7 [ default = false ];
}

message CreateNamespaceResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;

  optional bytes id = 2;
}

message IsCreateNamespaceDoneRequestPB {
  optional NamespaceIdentifierPB namespace = 1;
}

message IsCreateNamespaceDoneResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;

  // true if the create operation is completed, false otherwise
  optional bool done = 2;
}

// Database type is added to metadata entries such that PGSQL clients cannot delete or connect to
// CQL database_type and vice versa.
message DeleteNamespaceRequestPB {
  optional NamespaceIdentifierPB namespace = 1;

  // Database type.
  optional YQLDatabase database_type = 2 [ default = YQL_DATABASE_CQL ];
}
// Fails if the namespace is NOT empty

message DeleteNamespaceResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;
}

message IsDeleteNamespaceDoneRequestPB {
  optional NamespaceIdentifierPB namespace = 1;
}

message IsDeleteNamespaceDoneResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;

  // true if the delete operation completed, false otherwise
  optional bool done = 2;
}

message AlterNamespaceRequestPB {
  optional NamespaceIdentifierPB namespace = 1;

  // New name for the namespace in the alter operation.
  optional string new_name = 2;
}

message AlterNamespaceResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;
}

message ListNamespacesRequestPB {
  optional YQLDatabase database_type = 1 [ default = YQL_DATABASE_CQL ];
}

message ListNamespacesResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;

  repeated NamespaceIdentifierPB namespaces = 2;
}

message GetNamespaceInfoRequestPB {
  optional NamespaceIdentifierPB namespace = 1;
}

message GetNamespaceInfoResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;

  optional NamespaceIdentifierPB namespace = 2;
  optional bool colocated = 3;
}

// ============================================================================
//  Tablegroup
// ============================================================================

message CreateTablegroupRequestPB {
  required bytes id = 1;
  required bytes namespace_id = 2;
  optional string namespace_name = 3;
}

message CreateTablegroupResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;

  optional bytes parent_table_id = 2;
  optional bytes parent_table_name = 3;
}

message DeleteTablegroupRequestPB {
  required bytes id = 1;
  required bytes namespace_id = 2;
}

message DeleteTablegroupResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;

  optional bytes parent_table_id = 2;
}

message ListTablegroupsRequestPB {
  optional bytes namespace_id = 1;
}

message ListTablegroupsResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;

  repeated TablegroupIdentifierPB tablegroups = 2;
}

// ============================================================================
//  Authentication and Authorization
// ============================================================================

message CreateRoleRequestPB {
  optional string name = 1;
  optional string salted_hash = 2;
  optional bool login = 3;
  optional bool superuser = 4;
  // Name of the role creating this role.
  optional string creator_role_name = 5;
}

message CreateRoleResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;
}

message AlterRoleRequestPB {
  optional string name = 1;
  optional string salted_hash = 2;
  optional bool login = 3;
  optional bool superuser = 4;

  // Name of the role trying to alter the role.
  optional string current_role = 5;
}

message AlterRoleResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;
}

message DeleteRoleRequestPB {
  optional string name = 1;

  // Name of the role trying to drop the role.
  optional string current_role = 2;
}

message DeleteRoleResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;
}

message GrantRevokeRoleRequestPB {
  optional string granted_role = 1;
  optional string recipient_role = 2;

  // true if this is a revoke request.
  optional bool revoke = 3 [ default = false ];
}

message GrantRevokeRoleResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;
}

message GrantRevokePermissionRequestPB {
  optional PermissionType permission = 1;
  optional ResourceType resource_type = 2;
  optional string canonical_resource = 3;
  optional string resource_name = 4;
  optional NamespaceIdentifierPB namespace = 5;
  optional string role_name = 6;

  // true if this is a revoke request.
  optional bool revoke = 7 [ default = false ];
}

message GrantRevokePermissionResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;
}

message GetPermissionsRequestPB {
  // Only get the permissions if the cache version in the master is greater than this version.
  optional uint64 if_version_greater_than = 1;
}

message ResourcePermissionInfoPB {
  optional string canonical_resource = 1;
  // Bitmap representing the permissions.
  optional uint32 permissions = 2;
}

message RolePermissionInfoPB {
  optional string role = 1;
  // Bitmap representing the permissions for 'ALL KEYSPACES' and 'ALL ROLES'.
  optional uint32 all_keyspaces_permissions = 2;
  optional uint32 all_roles_permissions = 3;
  repeated ResourcePermissionInfoPB resource_permissions = 4;
  optional string salted_hash = 5;
  optional bool can_login = 6;
}

message GetPermissionsResponsePB {
  optional uint64 version = 1;
  optional MasterErrorPB error = 2;
  repeated RolePermissionInfoPB role_permissions = 3;
}

message RedisConfigSetRequestPB {
  optional string keyword = 1;
  repeated bytes args = 2;
}

message RedisConfigSetResponsePB {
  optional MasterErrorPB error = 1;
}

message RedisConfigGetRequestPB {
  optional string keyword = 1;
}

message RedisConfigGetResponsePB {
  optional string keyword = 1;
  repeated bytes args = 2;
  optional MasterErrorPB error = 3;
}

// ============================================================================
//  (User-Defined) Type
// ============================================================================

message CreateUDTypeRequestPB {
  optional NamespaceIdentifierPB namespace = 1;
  optional string name = 2;
  repeated string field_names = 3;
  repeated QLTypePB field_types = 4;
}

message CreateUDTypeResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;
  optional bytes id = 2;
}

message DeleteUDTypeRequestPB {
  optional UDTypeIdentifierPB type = 1;
}

message DeleteUDTypeResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;
}

message ListUDTypesRequestPB {
  optional NamespaceIdentifierPB namespace = 1;
}

message ListUDTypesResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;

  repeated UDTypeInfoPB udtypes = 2;
}

message GetUDTypeInfoRequestPB {
  optional UDTypeIdentifierPB type = 1;
}

message GetUDTypeInfoResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;
  optional UDTypeInfoPB udtype = 2;
}

message UDTypeIdentifierPB {
  // The table ID to fetch info.
  optional bytes type_id = 1;

  // The table name to fetch info.
  optional string type_name = 2;

  // The table namespace (if empty - using default namespace).
  optional NamespaceIdentifierPB namespace = 3;
}

message UDTypeInfoPB {
  optional bytes id = 1;
  optional string name = 2;
  repeated string field_names = 3;
  repeated QLTypePB field_types = 4;
  optional NamespaceIdentifierPB namespace = 5;
}

// ============================================================================
//  CDC Stream
// ============================================================================

message CreateCDCStreamRequestPB {
  optional string table_id = 1;
  repeated CDCStreamOptionsPB options = 3;
}

// Options for CDC stream. This will include details such as:
// Stream sink: YB Universe / Kafka / Elastic Search.
// Log retention time: Amount of time to retain logs for CDC.
// Sink details: For example, Kafka cluster IP, port.
message CDCStreamOptionsPB {
  optional string key = 1;
  optional bytes value = 2;
}

message CreateCDCStreamResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;
  optional bytes stream_id = 2;
}

message DeleteCDCStreamRequestPB {
  repeated bytes stream_id = 1;
}

message DeleteCDCStreamResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;
}

message ListCDCStreamsRequestPB {
  optional string table_id = 1;
}

message ListCDCStreamsResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;
  repeated CDCStreamInfoPB streams = 2;
}

message GetCDCStreamRequestPB {
  optional bytes stream_id = 1;
}

message GetCDCStreamResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;
  optional CDCStreamInfoPB stream = 2;
}

message CDCStreamInfoPB {
  optional bytes stream_id = 1;
  optional bytes table_id = 2;
  repeated CDCStreamOptionsPB options = 3;
}

// TODO: rename to FlushOrCompact TablesRequestPB
// https://github.com/YugaByte/yugabyte-db/issues/729
message FlushTablesRequestPB {
  repeated TableIdentifierPB tables = 1;

  // Whether we want to compact the tablets instead of flushing them.
  optional bool is_compaction = 2;

  // Whether we want to include index tables in this flush. If there are index tables in the tables
  // field this field must be set to false, otherwise the request will fail.
  optional bool add_indexes = 3;
}

message FlushTablesResponsePB {
  optional MasterErrorPB error = 1;

  optional bytes flush_request_id = 2;
}

message IsFlushTablesDoneRequestPB {
  optional bytes flush_request_id = 1;
}

message IsFlushTablesDoneResponsePB {
  optional MasterErrorPB error = 1;

  // true if the flush tables operation is completed, false otherwise.
  optional bool done = 2;

  // true if the flush tables operation is successful.
  optional bool success = 3;
}

// Reserve Postgres oid
message ReservePgsqlOidsRequestPB {
  optional bytes namespace_id = 1; // The namespace id of the Postgres database.
  optional uint32 next_oid = 2;    // The next oid to reserve.
  optional uint32 count = 3;       // The number of oids to reserve.
}

message ReservePgsqlOidsResponsePB {
  // The error, if an error occurred with this request.
  optional MasterErrorPB error = 1;
  optional uint32 begin_oid = 2; // The beginning oid reserved. Can be higher than requested.
  optional uint32 end_oid = 3;   // The end (exclusive) oid reserved.
}

message GetYsqlCatalogConfigRequestPB {
}

message GetYsqlCatalogConfigResponsePB {
  optional MasterErrorPB error = 1;
  optional uint64 version = 2;
}

message IsInitDbDoneRequestPB {
}

message IsInitDbDoneResponsePB {
  optional MasterErrorPB error = 1;

  // Someone started running initdb, as indicated by the existence of template1.pg_proc.
  optional bool pg_proc_exists = 2;

  // This is true if the master ran initdb and it finished, successfully or not.
  optional bool done = 4;

  // If this is set to a non-empty string, initdb has failed.
  optional string initdb_error = 5;
}

message SetupUniverseReplicationRequestPB {
  optional string producer_id = 1;
  repeated HostPortPB producer_master_addresses = 2;
  repeated string producer_table_ids = 3;

  // An id generated by the producer when BootstrapProducer rpc is called.
  repeated string producer_bootstrap_ids = 4;
}

message SetupUniverseReplicationResponsePB {
  optional MasterErrorPB error = 1;
}

message DeleteUniverseReplicationRequestPB {
  optional string producer_id = 1;
}

message DeleteUniverseReplicationResponsePB {
  optional MasterErrorPB error = 1;
}

message AlterUniverseReplicationRequestPB {
  optional string producer_id = 1;
  // The below options are currently mutually exclusive.  Only 1 operation at a time.
  repeated HostPortPB producer_master_addresses = 2;
  repeated string producer_table_ids_to_add = 4;
  repeated string producer_table_ids_to_remove = 5;
}

message AlterUniverseReplicationResponsePB {
  optional MasterErrorPB error = 1;
}

message SetUniverseReplicationEnabledRequestPB {
  optional string producer_id = 1;
  optional bool is_enabled = 2;
}

message SetUniverseReplicationEnabledResponsePB {
  optional MasterErrorPB error = 1;
}

message GetUniverseReplicationRequestPB {
  optional string producer_id = 1;
}

message GetUniverseReplicationResponsePB {
  optional MasterErrorPB error = 1;
  optional SysUniverseReplicationEntryPB entry = 2;
}

message SplitTabletRequestPB {
  required bytes tablet_id = 1;
}

message SplitTabletResponsePB {
  optional MasterErrorPB error = 1;
}

message DeleteTabletRequestPB {
  required bytes tablet_id = 1;
}

message DeleteTabletResponsePB {
  optional MasterErrorPB error = 1;
}

service MasterService {
  // TS->Master RPCs
  rpc TSHeartbeat(TSHeartbeatRequestPB) returns (TSHeartbeatResponsePB);

  // Client->Master RPCs
  rpc GetTabletLocations(GetTabletLocationsRequestPB) returns (GetTabletLocationsResponsePB);

  rpc CreateTable(CreateTableRequestPB) returns (CreateTableResponsePB);
  rpc IsCreateTableDone(IsCreateTableDoneRequestPB) returns (IsCreateTableDoneResponsePB);

  rpc TruncateTable(TruncateTableRequestPB) returns (TruncateTableResponsePB);
  rpc IsTruncateTableDone(IsTruncateTableDoneRequestPB) returns (IsTruncateTableDoneResponsePB);

  rpc BackfillIndex(BackfillIndexRequestPB) returns (BackfillIndexResponsePB);

  rpc DeleteTable(DeleteTableRequestPB) returns (DeleteTableResponsePB);
  rpc IsDeleteTableDone(IsDeleteTableDoneRequestPB) returns (IsDeleteTableDoneResponsePB);

  rpc AlterTable(AlterTableRequestPB) returns (AlterTableResponsePB);
  rpc IsAlterTableDone(IsAlterTableDoneRequestPB) returns (IsAlterTableDoneResponsePB);

  rpc ListTables(ListTablesRequestPB) returns (ListTablesResponsePB);
  rpc GetTableLocations(GetTableLocationsRequestPB) returns (GetTableLocationsResponsePB);
  rpc GetTableSchema(GetTableSchemaRequestPB) returns (GetTableSchemaResponsePB);

  rpc CreateNamespace(CreateNamespaceRequestPB) returns (CreateNamespaceResponsePB);
  rpc IsCreateNamespaceDone(IsCreateNamespaceDoneRequestPB)
      returns (IsCreateNamespaceDoneResponsePB);
  rpc DeleteNamespace(DeleteNamespaceRequestPB) returns (DeleteNamespaceResponsePB);
  rpc IsDeleteNamespaceDone(IsDeleteNamespaceDoneRequestPB)
      returns (IsDeleteNamespaceDoneResponsePB);
  rpc AlterNamespace(AlterNamespaceRequestPB) returns (AlterNamespaceResponsePB);
  rpc ListNamespaces(ListNamespacesRequestPB) returns (ListNamespacesResponsePB);
  rpc GetNamespaceInfo(GetNamespaceInfoRequestPB) returns (GetNamespaceInfoResponsePB);

  // For Tablegroup:
  rpc CreateTablegroup(CreateTablegroupRequestPB) returns (CreateTablegroupResponsePB);
  rpc DeleteTablegroup(DeleteTablegroupRequestPB) returns (DeleteTablegroupResponsePB);
  rpc ListTablegroups(ListTablegroupsRequestPB) returns (ListTablegroupsResponsePB);

  // For Postgres:
  rpc ReservePgsqlOids(ReservePgsqlOidsRequestPB) returns (ReservePgsqlOidsResponsePB);
  rpc GetYsqlCatalogConfig(GetYsqlCatalogConfigRequestPB) returns (GetYsqlCatalogConfigResponsePB);

  //  Authentication and Authorization.
  rpc CreateRole(CreateRoleRequestPB) returns (CreateRoleResponsePB);
  rpc AlterRole(AlterRoleRequestPB) returns (AlterRoleResponsePB);
  rpc DeleteRole(DeleteRoleRequestPB) returns (DeleteRoleResponsePB);
  rpc GrantRevokeRole(GrantRevokeRoleRequestPB) returns (GrantRevokeRoleResponsePB);
  rpc GrantRevokePermission(GrantRevokePermissionRequestPB)
      returns (GrantRevokePermissionResponsePB);
  rpc GetPermissions(GetPermissionsRequestPB) returns (GetPermissionsResponsePB);

  rpc CreateUDType(CreateUDTypeRequestPB) returns (CreateUDTypeResponsePB);
  rpc DeleteUDType(DeleteUDTypeRequestPB) returns (DeleteUDTypeResponsePB);
  rpc ListUDTypes(ListUDTypesRequestPB) returns (ListUDTypesResponsePB);
  rpc GetUDTypeInfo(GetUDTypeInfoRequestPB) returns (GetUDTypeInfoResponsePB);

  // CDC stream RPCs.
  rpc CreateCDCStream(CreateCDCStreamRequestPB) returns (CreateCDCStreamResponsePB);
  rpc DeleteCDCStream(DeleteCDCStreamRequestPB) returns (DeleteCDCStreamResponsePB);
  rpc ListCDCStreams(ListCDCStreamsRequestPB) returns (ListCDCStreamsResponsePB);
  rpc GetCDCStream(GetCDCStreamRequestPB) returns (GetCDCStreamResponsePB);

  // Redis Config
  rpc RedisConfigSet(RedisConfigSetRequestPB) returns (RedisConfigSetResponsePB);
  rpc RedisConfigGet(RedisConfigGetRequestPB) returns (RedisConfigGetResponsePB);

  // Administrative/monitoring RPCs
  rpc ListTabletServers(ListTabletServersRequestPB) returns (ListTabletServersResponsePB);
  rpc ListMasters(ListMastersRequestPB) returns (ListMastersResponsePB);
  rpc ListMasterRaftPeers(ListMasterRaftPeersRequestPB) returns (ListMasterRaftPeersResponsePB);
  rpc GetMasterRegistration(GetMasterRegistrationRequestPB) returns
    (GetMasterRegistrationResponsePB);

  // Get the ready status from the catalog manager for this master.
  // NOTE: Should be used only for unit testing purposes.
  rpc IsMasterLeaderServiceReady(IsMasterLeaderReadyRequestPB)
      returns (IsMasterLeaderReadyResponsePB);

  // Dump master state from all the peers in the current master's quorum
  rpc DumpState(DumpMasterStateRequestPB) returns (DumpMasterStateResponsePB);

  rpc ChangeLoadBalancerState(ChangeLoadBalancerStateRequestPB)
      returns (ChangeLoadBalancerStateResponsePB);
  rpc GetLoadBalancerState(GetLoadBalancerStateRequestPB) returns (GetLoadBalancerStateResponsePB);

  rpc RemovedMasterUpdate(RemovedMasterUpdateRequestPB) returns (RemovedMasterUpdateResponsePB);

  rpc SetPreferredZones(SetPreferredZonesRequestPB) returns (SetPreferredZonesResponsePB);
  rpc GetMasterClusterConfig(GetMasterClusterConfigRequestPB)
      returns (GetMasterClusterConfigResponsePB);
  rpc ChangeMasterClusterConfig(ChangeMasterClusterConfigRequestPB)
      returns (ChangeMasterClusterConfigResponsePB);
  rpc GetLoadMoveCompletion(GetLoadMovePercentRequestPB)
      returns (GetLoadMovePercentResponsePB);
  rpc GetLeaderBlacklistCompletion(GetLeaderBlacklistPercentRequestPB)
      returns (GetLoadMovePercentResponsePB);
  rpc IsLoadBalanced(IsLoadBalancedRequestPB)
      returns (IsLoadBalancedResponsePB);
  rpc IsLoadBalancerIdle(IsLoadBalancerIdleRequestPB)
      returns (IsLoadBalancerIdleResponsePB);
  rpc AreLeadersOnPreferredOnly(AreLeadersOnPreferredOnlyRequestPB)
      returns (AreLeadersOnPreferredOnlyResponsePB);

  rpc FlushTables(FlushTablesRequestPB) returns (FlushTablesResponsePB);
  rpc IsFlushTablesDone(IsFlushTablesDoneRequestPB) returns (IsFlushTablesDoneResponsePB);

  rpc IsInitDbDone(IsInitDbDoneRequestPB) returns (IsInitDbDoneResponsePB);

  rpc ChangeEncryptionInfo(ChangeEncryptionInfoRequestPB) returns (ChangeEncryptionInfoResponsePB);

  rpc IsEncryptionEnabled(IsEncryptionEnabledRequestPB) returns (IsEncryptionEnabledResponsePB);

  rpc SetupUniverseReplication(SetupUniverseReplicationRequestPB)
      returns (SetupUniverseReplicationResponsePB);
  rpc DeleteUniverseReplication(DeleteUniverseReplicationRequestPB)
      returns (DeleteUniverseReplicationResponsePB);
  rpc AlterUniverseReplication(AlterUniverseReplicationRequestPB)
      returns (AlterUniverseReplicationResponsePB);
  rpc SetUniverseReplicationEnabled(SetUniverseReplicationEnabledRequestPB)
      returns (SetUniverseReplicationEnabledResponsePB);
  rpc GetUniverseReplication(GetUniverseReplicationRequestPB)
      returns (GetUniverseReplicationResponsePB);
  rpc AddUniverseKeys(AddUniverseKeysRequestPB)  returns (AddUniverseKeysResponsePB);
  rpc GetUniverseKeyRegistry(GetUniverseKeyRegistryRequestPB)
      returns (GetUniverseKeyRegistryResponsePB);
  rpc HasUniverseKeyInMemory(HasUniverseKeyInMemoryRequestPB)
      returns (HasUniverseKeyInMemoryResponsePB);

  rpc SplitTablet(SplitTabletRequestPB) returns (SplitTabletResponsePB);
  rpc DeleteTablet(DeleteTabletRequestPB) returns (DeleteTabletResponsePB);
}
